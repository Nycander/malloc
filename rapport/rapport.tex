\documentclass[a4paper,10pt,titlepage]{article}
% Språk och encodings
\usepackage[swedish,english]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage[fixlanguage]{babelbib}
% Images and floats
\usepackage{graphicx}
\usepackage{wrapfig}
\usepackage{float}
% Clear type + Sans-serif font
\usepackage{lmodern}
\renewcommand{\familydefault}{\sfdefault}
% Avancerade tabeller
\usepackage{tabularx}
\usepackage{multirow}
\usepackage{booktabs}
% Matte
\usepackage{amsmath, amsthm, amssymb}
% Algoritmer
\usepackage[ruled,vlined]{algorithm2e}
% Källkod
\usepackage{listings}
\lstset{
	showspaces = false,
	showstringspaces = false,
}
% Inkludera pdf-sidor
\usepackage{pdfpages}
% Länkar
\usepackage{color}
\definecolor{dark-blue}{rgb}{0, 0, 0.6}
\usepackage{hyperref}
\hypersetup{
  colorlinks=true,
  linkcolor=dark-blue,
  urlcolor=dark-blue
}
% Vettiga paragrafer
\setlength{\parindent}{0pt}
\setlength{\parskip}{2ex}

% Kommando för kommandorader
\newcommand{\cmdline}[1]{\mbox{\textbf{\texttt{> #1}}}}

% Kommandon för testfall
\usepackage{testcases}

% Sidhuvud/sidfot
\usepackage{fancyhdr}
\setlength{\headheight}{15pt}
\pagestyle{fancyplain}
\lfoot{Carl-Oscar Erneholm \\ 880422-0872 \\ coer@kth.se}
\rfoot{Martin Nycander \\ 881028-0076 \\ mnyc@kth.se}
\cfoot{Sida \thepage}

% Språk
\selectbiblanguage{swedish}
\selectlanguage{swedish}

% Titel
\title{Laborationsrapport 3 \\ Minneshantering v. 3.21}
\author{Carl-Oscar Erneholm \and Martin Nycander}
\date{\today}

\begin{document}

\includepdf[pages=-]{framsida.pdf}

\maketitle

\tableofcontents
\thispagestyle{empty}
\newpage
\setcounter{page}{1}
\section{Problembeskrivning}

De olika minnesallokeringsmetoderna som ska implementeras är:

\begin{description}
	\item[First-fit] Första bästa tillräckligt stora blocket används.
	\item[Best-fit] Det minsta lediga blocket med tillräckligt många bytes allokeras.
	\item[Worst-fit] Det största lediga blocket används och fragmenteras.
	\item[Quick-fit] Som Best-fit, men istället för att alla block kontrolleras så har man ett antal listor med minne av olika storlek.
\end{description}

\subsection{Förberedelsefråga}

\begin{enumerate}
\item[1.] \textbf{\footnotesize Hur mycket minne slösas bort i medel och i värsta fallet i de block som allokeras via malloc() ur ``Quick fit'' listorna?}

Quick fit listorna tar emot block av jämna två potenser av ett
förutbestämmt värde. Det betyder att den tillåtna blockstorleken i
varje lista dubblas för varje liste ända tills den sista listan. I
det värsta fallet får ett block precis inte plats i ett en lista utan är en
enhet för stor, vilket betyder att den måste placeras i listan för dubbelt så
stora block.

\begin{math}
n+1 > n\\
2n - (n+1)\\
n-1\\
\frac{n-1}{2n} \approx \frac{1}{2}\\
\end{math}

Där n är storleken på blocket där minnet inte fick plats.
Eftersom minnet vi ville allokera bara är något större än det block den inte
fick plats i är den mycket nära hälften så stor nästa lista med dubbelt så många
block. Alltså spiller vi i värsta fall nästan $50\%$ av allt vi allokerar.

Medelvärdet av minnes spillet när man använder Quick Fit ökar när block
storleken ökar (man har fler listor som tillåter större block). Den största
andelen spill kommer att komma ifrån de större block listorna, eftersom dem har
mer minne att spilla. Medelvärdet kommer alltså att domineras av de större
blockstorlekarna. De större blockstorlekarna kommer dessutom att ha ett mycket
snarlikt medelvärde, alltså kan vi approximera hela medelvärdet till medelvärdet
av det största blocket.

\begin{math}
\sum^n_{i=1}\frac{i}{n} = 2n + 1
\end{math}

\end{enumerate}

\newpage
\section{Programbeskrivning}

\newpage
\section{Prestandautvärdering}

% TODO: Använd testcases för att standardisera hur prestandamätningen görs

% TODO: GRAFER! PIE-CHARTS!!!!!!!!

% TODO: Noggrannhet?

\newpage
\section{Labbutvärdering}

\end{document}
